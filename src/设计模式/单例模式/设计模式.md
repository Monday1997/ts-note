## 最终实现

```ts
// fn永远只会单次执行，用于创建对象或者一些如click的事件注册
function getSingle(fn:Function){
    let instance:any = null 
    return function(...arg:any[]){
        return instance || (instance=fn.apply(this,arg))
    }
}
```

使用

```ts
// 惰性单例
 function createWin(html:any){
    const div = document.createElement('div')
    div.innerHTML = html
    div.classList.add('aaa')
    div.style.display = 'none'
    document.body.appendChild(div)
    return div
}
const singleWin = getSingle(createWin)

function click(){
    const win = singleWin()
    win.style.display = 'block'
} 
```

## 导入

例如一个弹窗，我们每次点击按钮的时候都能弹出，并且能够复用，可以封装一个如下方法

```ts
function createWin(html:string){
    const div = document.createElement('div')
    div.innerHTML = html
    div.classList.add('someClass')
    div.style.display = 'block'
    document.body.appendChild(div)
    return div
}
```

点击时能够调用，如下

```ts
btn.onclick=function(){
     createWin('这是一个弹窗')
}
```

但是如果每次都这样调用会重复创建div,如果把div先创建好如下

```ts
function createWin(html:string){
    const div = document.createElement('div')
    div.innerHTML = html
    div.classList.add('someClass')
    div.style.display = 'none'//改为隐藏
    document.body.appendChild(div)
    return div
}
const win = createWin('这是一个弹窗')
btn.onclick=function(){
    win.style.display='block'
}
```

但是这样一来创建了一个多余的win变量，

二来我们还没执行click操作就已经产生了div元素，而用户不一定会调用click，此时直接创建元素也会导致性能浪费。此处只是举例，现实中其他场景可能希望我们不要直接执行，而是用户操作了再执行。

## 单例模式

通过这个例子引入单例模式

单例模式简单来说就是多次进行创建，但最后得到的是同一个实例

### class实现

普通单例通常是针对class来说的，通常我们的做法如下

使用一个getInstance去调用，然后通过判断缓存instance变量，首次进入将instance赋值，后续直接通过instance是否存在来考虑是否要进行实例化，但是这样每一个类都要去设置instance属性和getInstance方法，于是设置一个通用的getSingleClass如下

```ts
type Tclass = { new(...arg: any[]): any }
type TInstanceClass<T extends Tclass> = { new(...arg: any[]): InstanceType<T> }&{destroy:Function}
const getSingleClass= <T extends Tclass>(userClass:T):TInstanceClass<T> => {
    let instance: any = null
    const fn: TInstanceClass<T> = function (...arg: any[]) {
        return instance || (instance = new userClass(...arg))
    } as any
    (fn as any).destroy = function(...args:any[]){
        instance && instance.destroy?.(args)
        instance = null
    }
    return fn
}
```

接下来实现案例

```ts

class CreateWin {
    div = null
    constructor(html: string) {
        const div = document.createElement('div')
        div.innerHTML = html
        div.classList.add('aaa')
        div.style.display = 'none'
        document.body.appendChild(div)
        this.div = div
    }
}

const SingleWin = getSingleClass(CreateWin)
const btn = document.getElementById('btn')
btn.onclick = ()=>{
    const div = new SingleWin('这是一个弹框')
    div.style.display = 'block'
}
// 适当时候调用 SingleWin.destroy()
```

### fn实现

再前端中更多的是用到fn，所以写个再写个fn的单例

```ts
// fn永远只会单次执行，用于创建对象或者一些如click的事件注册
function getSingle(fn:Function){
    let instance:any = null 
     function singleFn(...arg:any[]){
        return instance || (instance=fn.apply(this,arg))
    }
    return singleFn
}

```

```ts
function createWin(html:any){
    const div = document.createElement('div')
    div.innerHTML = html
    div.classList.add('aaa').
    div.style.display = 'none'
    document.body.appendChild(div)
    return div
}

const singleWin = getSingle(createWin)
function click(){
    const win = singleWin()
    win.style.display = 'block'
}
```

除了创造实例外还可以用于注册事件，例如

```ts
// 渲染即绑定
function getSingle(fn:Function){
    let instance:any = null 
     function singleFn(...arg:any[]){
        return instance || (instance=fn.apply(this,arg))
    }
   
    return singleFn
}
const bindEvent = getSingle(()=>{
    document.getElementById('id').onclick=function(){
        alert('1')
    }
    return true
})
const render = ()=>{
    bindEvent()
}
// 多次render 只会对数据进行一次绑定
render()
render()
render()
```



